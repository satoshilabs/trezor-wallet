'use strict';

exports.__esModule = true;
exports.clearTimeout = exports.dispose = exports.postMessage = exports.init = exports.messagePromises = exports.error = exports.timeout = exports.initPromise = exports.origin = exports.instance = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _deferred = require('../utils/deferred');

var _ui = require('../constants/ui');

var _errors = require('../constants/errors');

var _inlineStyles = require('./inline-styles');

var _inlineStyles2 = _interopRequireDefault(_inlineStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var instance = exports.instance = void 0;
var origin = exports.origin = void 0;
var initPromise = exports.initPromise = (0, _deferred.create)();
var timeout = exports.timeout = 0;
var error = exports.error = void 0;

var _messageID = 0;
// every postMessage to iframe has its own promise to resolve
var messagePromises = exports.messagePromises = {};

var init = exports.init = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(settings) {
        var existedFrame, src, iframeSrcHost, onLoad;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        existedFrame = document.getElementById('trezorconnect');

                        if (existedFrame) {
                            exports.instance = instance = existedFrame;
                        } else {
                            exports.instance = instance = document.createElement('iframe');
                            instance.frameBorder = '0';
                            instance.width = '0px';
                            instance.height = '0px';
                            instance.style.position = 'absolute';
                            instance.style.display = 'none';
                            instance.style.border = '0px';
                            instance.style.width = '0px';
                            instance.style.height = '0px';
                            instance.id = 'trezorconnect';
                        }

                        src = settings.iframeSrc + '?' + Date.now();

                        instance.setAttribute('src', src);
                        if (settings.webusb) {
                            instance.setAttribute('allow', 'usb');
                        }

                        // eslint-disable-next-line no-irregular-whitespace, no-useless-escape
                        iframeSrcHost = instance.src.match(/^.+\:\/\/[^\‌​/]+/);

                        if (iframeSrcHost && iframeSrcHost.length > 0) {
                            exports.origin = origin = iframeSrcHost[0];
                        }

                        exports.timeout = timeout = window.setTimeout(function () {
                            initPromise.reject(_errors.IFRAME_TIMEOUT);
                        }, 10000);

                        onLoad = function onLoad() {
                            if (!instance) {
                                initPromise.reject(_errors.IFRAME_BLOCKED);
                                return;
                            }
                            try {
                                // if hosting page is able to access cross-origin location it means that the iframe is not loaded
                                var iframeOrigin = instance.contentWindow.location.origin;
                                if (!iframeOrigin || iframeOrigin === 'null') {
                                    // eslint-disable-next-line no-use-before-define
                                    handleIframeBlocked();
                                    return;
                                }
                            } catch (e) {
                                // empty
                            }

                            var extension = void 0;
                            // $FlowIssue chrome is not declared outside
                            if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
                                chrome.runtime.onConnect.addListener(function () {});
                                extension = chrome.runtime.id;
                            }

                            instance.contentWindow.postMessage({
                                type: _ui.IFRAME_HANDSHAKE,
                                payload: {
                                    settings: settings,
                                    extension: extension
                                }
                            }, origin);

                            instance.onload = undefined;
                        };

                        // IE hack


                        if (instance.attachEvent) {
                            instance.attachEvent('onload', onLoad);
                        } else {
                            instance.onload = onLoad;
                        }
                        // inject iframe into host document body
                        if (document.body) {
                            document.body.appendChild(instance);
                            // eslint-disable-next-line no-use-before-define
                            injectStyleSheet();
                        }

                        _context.prev = 11;
                        _context.next = 14;
                        return initPromise.promise;

                    case 14:
                        _context.next = 19;
                        break;

                    case 16:
                        _context.prev = 16;
                        _context.t0 = _context['catch'](11);
                        throw _context.t0.message || _context.t0;

                    case 19:
                        _context.prev = 19;

                        window.clearTimeout(timeout);
                        exports.timeout = timeout = 0;
                        return _context.finish(19);

                    case 23:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, undefined, [[11, 16, 19, 23]]);
    }));

    return function init(_x) {
        return _ref.apply(this, arguments);
    };
}();

var injectStyleSheet = function injectStyleSheet() {
    if (!instance) {
        throw _errors.IFRAME_BLOCKED;
    }
    var doc = instance.ownerDocument;
    var head = doc.head || doc.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.setAttribute('id', 'TrezorConnectStylesheet');

    // $FlowIssue
    if (style.styleSheet) {
        // IE
        // $FlowIssue
        style.styleSheet.cssText = _inlineStyles2.default;
    } else {
        style.appendChild(document.createTextNode(_inlineStyles2.default));
    }
    head.append(style);
};

var handleIframeBlocked = function handleIframeBlocked() {
    window.clearTimeout(timeout);

    exports.error = error = _errors.IFRAME_BLOCKED.message;
    // eslint-disable-next-line no-use-before-define
    dispose();
    initPromise.reject(_errors.IFRAME_BLOCKED);
};

// post messages to iframe
var postMessage = exports.postMessage = function postMessage(message) {
    var usePromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (!instance) {
        throw _errors.IFRAME_BLOCKED;
    }
    if (usePromise) {
        _messageID++;
        message.id = _messageID;
        messagePromises[_messageID] = (0, _deferred.create)();
        instance.contentWindow.postMessage(message, origin);
        return messagePromises[_messageID].promise;
    }

    instance.contentWindow.postMessage(message, origin);
    return null;
};

var dispose = exports.dispose = function dispose() {
    if (instance && instance.parentNode) {
        try {
            instance.parentNode.removeChild(instance);
        } catch (error) {
            // do nothing
        }
    }
    exports.instance = instance = null;
    exports.timeout = timeout = 0;
};

var clearTimeout = exports.clearTimeout = function clearTimeout() {
    window.clearTimeout(timeout);
};